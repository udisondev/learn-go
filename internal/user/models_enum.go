// Code generated by go-enum DO NOT EDIT.
// Version: v0.9.1

// Built By: go install

package user

import (
	"database/sql/driver"
	"errors"
	"fmt"
)

const (
	// SubPlanFree is a SubPlan of type Free.
	SubPlanFree SubPlan = iota
	// SubPlanBasic is a SubPlan of type Basic.
	SubPlanBasic
	// SubPlanStandard is a SubPlan of type Standard.
	SubPlanStandard
	// SubPlanPremium is a SubPlan of type Premium.
	SubPlanPremium
)

var ErrInvalidSubPlan = errors.New("not a valid SubPlan")

const _SubPlanName = "freebasicstandardpremium"

var _SubPlanMap = map[SubPlan]string{
	SubPlanFree:     _SubPlanName[0:4],
	SubPlanBasic:    _SubPlanName[4:9],
	SubPlanStandard: _SubPlanName[9:17],
	SubPlanPremium:  _SubPlanName[17:24],
}

// String implements the Stringer interface.
func (x SubPlan) String() string {
	if str, ok := _SubPlanMap[x]; ok {
		return str
	}
	return fmt.Sprintf("SubPlan(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x SubPlan) IsValid() bool {
	_, ok := _SubPlanMap[x]
	return ok
}

var _SubPlanValue = map[string]SubPlan{
	_SubPlanName[0:4]:   SubPlanFree,
	_SubPlanName[4:9]:   SubPlanBasic,
	_SubPlanName[9:17]:  SubPlanStandard,
	_SubPlanName[17:24]: SubPlanPremium,
}

// ParseSubPlan attempts to convert a string to a SubPlan.
func ParseSubPlan(name string) (SubPlan, error) {
	if x, ok := _SubPlanValue[name]; ok {
		return x, nil
	}
	return SubPlan(0), fmt.Errorf("%s is %w", name, ErrInvalidSubPlan)
}

var errSubPlanNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *SubPlan) Scan(value interface{}) (err error) {
	if value == nil {
		*x = SubPlan(0)
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case int64:
		*x = SubPlan(v)
	case string:
		*x, err = ParseSubPlan(v)
	case []byte:
		*x, err = ParseSubPlan(string(v))
	case SubPlan:
		*x = v
	case int:
		*x = SubPlan(v)
	case *SubPlan:
		if v == nil {
			return errSubPlanNilPtr
		}
		*x = *v
	case uint:
		*x = SubPlan(v)
	case uint64:
		*x = SubPlan(v)
	case *int:
		if v == nil {
			return errSubPlanNilPtr
		}
		*x = SubPlan(*v)
	case *int64:
		if v == nil {
			return errSubPlanNilPtr
		}
		*x = SubPlan(*v)
	case float64: // json marshals everything as a float64 if it's a number
		*x = SubPlan(v)
	case *float64: // json marshals everything as a float64 if it's a number
		if v == nil {
			return errSubPlanNilPtr
		}
		*x = SubPlan(*v)
	case *uint:
		if v == nil {
			return errSubPlanNilPtr
		}
		*x = SubPlan(*v)
	case *uint64:
		if v == nil {
			return errSubPlanNilPtr
		}
		*x = SubPlan(*v)
	case *string:
		if v == nil {
			return errSubPlanNilPtr
		}
		*x, err = ParseSubPlan(*v)
	}

	return
}

// Value implements the driver Valuer interface.
func (x SubPlan) Value() (driver.Value, error) {
	return x.String(), nil
}
